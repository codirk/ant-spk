package net.filebot.ant.spk;

import static net.filebot.ant.spk.PackageTask.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

import org.apache.commons.openpgp.ant.OpenPgpSignerTask;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.taskdefs.Concat;
import org.apache.tools.ant.taskdefs.Tar.TarFileSet;
import org.apache.tools.ant.types.Resource;

public class CodeSignTask extends Task {

	// user properties
	String keyId;
	File pubring;
	File secring;

	String password = ""; // empty password by default
	String timestamp = "http://timestamp.synology.com/timestamp.php"; // default Synology signature server

	public void setKeyId(String keyId) {
		this.keyId = keyId;
	}

	public void setPubring(File pubring) {
		this.pubring = pubring;
	}

	public void setSecring(File secring) {
		this.secring = secring;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public void setTimestamp(String timestamp) {
		this.timestamp = timestamp;
	}

	// internal properties
	File token = new File(SYNO_SIGNATURE);
	List<TarFileSet> cats = new ArrayList<TarFileSet>();

	public void setToken(File token) {
		this.token = token;
	}

	public void addConfiguredCat(TarFileSet files) {
		cats.add(files);
	}

	@Override
	public void execute() {
		// temporary files
		File allcat = new File("ALLCAT.dat");
		File allsig = new File("ALLCAT.dat.asc"); // generated by <signer> default mapper

		Concat concat = new Concat();
		concat.setProject(getProject());
		concat.setDestfile(allcat);
		concat.setBinary(true);
		concat.setOverwrite(true);

		// cat files in case-sensitive alphabetical tar entry path order
		TreeMap<String, Resource> sortedCats = new TreeMap<String, Resource>();
		cats.forEach(fs -> {
			fs.setProject(getProject());
			fs.forEach(r -> {
				sortedCats.put(getTarEntryName(r.getName(), fs), r);
			});
		});

		log(String.format("CAT: Prepare package data (%,d files, %,d bytes)", sortedCats.size(), sortedCats.values().stream().mapToLong(r -> r.getSize()).sum()));
		sortedCats.values().forEach(concat::add);
		concat.execute();

		// GPG sign all cat data
		log("GPG: sign with key " + keyId);

		OpenPgpSignerTask signer = new OpenPgpSignerTask();
		signer.setProject(getProject());
		signer.setAsciiarmor(true);
		signer.setPubring(pubring);
		signer.setSecring(secring);
		signer.setPassword(password);
		signer.setKeyId(keyId);
		signer.setArtefact(allcat);

		// sign the binary data
		signer.execute();

		// sign the signature
		log("SYNO: Submit signature to " + timestamp);

		try (CloseableHttpClient httpClient = HttpClientBuilder.create().build()) {
			HttpPost httpPost = new HttpPost(timestamp);

			HttpEntity pastData = MultipartEntityBuilder.create().addBinaryBody("file", allsig).build();
			httpPost.setEntity(pastData);

			HttpResponse response = httpClient.execute(httpPost);
			Files.copy(response.getEntity().getContent(), token.toPath(), StandardCopyOption.REPLACE_EXISTING);
		} catch (IOException e) {
			throw new BuildException("Failed to retrieve signature to " + timestamp);
		} finally {
			allcat.delete();
			allsig.delete();
		}
	}

	protected String getTarEntryName(String vPath, TarFileSet tarFileSet) {
		if (vPath.isEmpty() || vPath.startsWith("/"))
			throw new IllegalArgumentException("Illegal tar entry: " + vPath);

		String fullpath = tarFileSet.getFullpath(getProject());
		if (fullpath.length() > 0) {
			return fullpath;
		}

		String prefix = tarFileSet.getPrefix(getProject());
		if (prefix.length() > 0) {
			if (prefix.endsWith("/")) {
				return prefix + vPath;
			} else {
				return prefix + '/' + vPath;
			}
		}

		return vPath;
	}
}
